# Kickstart file automatically generated by anaconda.
#version=DEVEL

#Net install URL
url --url="{{ provisioning_net_install_url }}"

#Keyboard layout
lang en_US.UTF-8
keyboard --vckeymap=us --xlayouts=''

#Accept EULA
eula --agreed

#Timezone
timezone --utc America/Argentina/Buenos_Aires

{% if provisioning_dhcp_boot_eth != "" %}
#PXE Install only
#Disable LAN on next boot
network --bootproto=dhcp --device={{ provisioning_dhcp_boot_eth }} --activate --onboot=no
{% endif %}

#Network configuration
{% if network_ether_interfaces is defined %}
{% for interface in network_ether_interfaces %}
{% if interface.device == provisioning_net_install_eth %}
{% if interface.vlan | default('no') | lower == "yes" %}
network --bootproto=static --onboot=yes --device={{ interface.device.split(".")[0] }} --vlanid={{ interface.device.split(".")[1] }} --ip={{ interface.address }} --netmask={{ interface.netmask }} --gateway={{ interface.gateway }} --nameserver=8.8.8.8 --nameserver=8.8.4.4
{% else %}
network --bootproto=static --onboot=yes --device={{ interface.device }} --ip={{ interface.address }} --netmask={{ interface.netmask }} --gateway={{ interface.gateway }} --nameserver=8.8.8.8 --nameserver=8.8.4.4
{% endif %}
{% endif %}
{% endfor %}
{% endif %}
{% if network_bridge_interfaces is defined %}
{% for bridge in network_bridge_interfaces %}
{% if bridge.ports is defined %}
{% for port in bridge.ports %}
{% if port.device == provisioning_net_install_eth %}
{% if port.vlan | default('no') | lower == "yes" %}
network --bootproto=static --onboot=yes --device={{ port.device.split(".")[0] }} --vlanid={{ port.device.split(".")[1] }} --ip={{ bridge.address }} --netmask={{ bridge.netmask }} --gateway={{ bridge.gateway }} --nameserver=8.8.8.8 --nameserver=8.8.4.4
{% else %}
network --bootproto=static --onboot=yes --device={{ port.device }} --ip={{ bridge.address }} --netmask={{ bridge.netmask }} --gateway={{ bridge.gateway }} --nameserver=8.8.8.8 --nameserver=8.8.4.4
{% endif %}
{% endif %}
{% endfor %}
{% endif %}
{% endfor %}
{% endif %}

# Enable NetworkManager for the network to work
services --enabled="NetworkManager"

#Encrypted password
rootpw  --iscrypted {{ provisioning_root_default_password }}

#Disable selinux
selinux --disabled

%pre --log /tmp/pre-install.log
#!/bin/bash
set -x

#Removing previous volume groups
vgdisplay | grep "VG Name" | awk '{print "/dev/"$3}' | xargs --no-run-if-empty vgremove -f 

#
# This script compensates for limitations in the clearpart and part directives that 
# will set alternate partition label names if the desired name already exists on the
# disk partition. The workaround is to clear the partition labels before the clearpart 
# and part directives run to make them think that the disk has no prior partitions or labels.
#

alldisks=$( sfdisk -d | grep "/dev/"| grep "^#" | cut -d " " -f5 )
allparts=$( sfdisk -d | grep "/dev/"| grep -v "^#" | cut -d ":" -f1 )
for disk in $alldisk
do
  # delete mbr
  dd if=/dev/zero of=$disk bs=446 count=1
done

for part in $allparts
do
  wipefs -a $part
  /usr/sbin/e2label $part " "
  dd if=/dev/zero of=$part bs=512 seek=$(( $(blockdev --getsz $part) - 1024 )) count=1024
  dd if=/dev/zero of=$part bs=512 count=16
done

# Exit on errors
#set -e

# Get the disks
COUNT=0
BOOTGPT=0
for DISK in $(awk '{if ($NF ~ "^(s|h)d|cciss|nvme" && $NF !~ "(((s|h)d|c.d.)[a-z][0-9])|(nvme[0-9]n[1-9]p[0-9])$") print $4}' /proc/partitions | sort ); do
    DEVS1[${COUNT}]="${DISK}"
    DISKS[${COUNT}]="${DISK//\/dev\/}"
	
	DISKSIZE=$(parted -sm /dev/${DISK} unit GB print | grep -e "${DISK}" | cut -d: -f2 | sed -e 's/GB$//')
	if [ -e /sys/firmware/efi -o ${DISKSIZE} -gt 2100 ]; then
		BOOTGPT=1
	fi

    let COUNT++
done

# Define the RAID level
if [ "{{ provisioning_raid_level | default('') }}" != "" ]; then
    LEVEL="{{ provisioning_raid_level | default('') }}"
elif [ ${COUNT} -eq "1" ]; then
    LEVEL=-1
elif [ ${COUNT} -eq "2" ]; then
    LEVEL=1
elif [ ${COUNT} -eq "3" ]; then
    LEVEL=5
elif [ ${COUNT} -eq "4" ]; then
    LEVEL=10
elif [ ${COUNT} -ge "4" ]; then
    LEVEL=JBOD
fi

echo "# LEVEL=${LEVEL}" >> /tmp/partitioning.txt

#Use SSDs connected to motherboard as OSs disks if possible
# Arrays help https://www.thegeekstuff.com/2010/06/bash-array-tutorial/
if [ ${LEVEL} = "JBOD" ]; then
	LEVEL=1
	DISKSPATH=(/dev/disk/by-path/*)
	OSDISKS=( $( for i in ${DISKSPATH[@]} ; do echo $i ; done | grep -E 'pci-0000:00:1f.2-ata-[0-9]\.[0-9]$' ) )

	{% raw %}
	if [ ${#OSDISKS[@]} -eq 0 ]; then
	{% endraw %}
		DEVS2=("${DEVS1[@]:0:2}")
	else
		DEVS2=("${OSDISKS[@]:0:2}")
	fi
else
	DEVS2=("${DEVS1[@]}")
fi

function join_by { local IFS="$1"; shift; echo "$*"; }
DEVSCSS=$(join_by , "${DEVS2[@]}")

echo "# DEVS1=${DEVS1[@]}" >> /tmp/partitioning.txt
echo "# DEVS2=${DEVS2[@]}" >> /tmp/partitioning.txt
echo "# DEVSCSS=${DEVSCSS}" >> /tmp/partitioning.txt

# Create RAID + LVM (if the system has two disks or more)
if [ ${LEVEL} -ge "1" ]; then
	{% raw %}
    x=${#DEVS2[@]}
	{% endraw %}
    echo "zerombr" >> /tmp/partitioning.txt
    echo "clearpart --all" >> /tmp/partitioning.txt
	echo "bootloader --location=mbr --driveorder=${DEVSCSS} --append=\"crashkernel=auto rhgb quiet net.ifnames=0 biosdevname=0\"" >> /tmp/partitioning.txt
	{% raw %}
    for ((i=0; i < ${#DEVS2[@]}; i++)); do
	{% endraw %}
		if [ ${BOOTGPT} -eq "1" ]; then
			echo "part biosboot --fstype=biosboot --size=1 --ondrive=${DEVS2[$i]}" >> /tmp/partitioning.txt
		fi
        echo "part raid.0${i} --asprimary --size=512 --ondrive=${DEVS2[$i]}" >> /tmp/partitioning.txt
        echo "part raid.0${x} --asprimary --size={{ provisioning_total_volgroup_size }} --ondrive=${DEVS2[$i]}" >> /tmp/partitioning.txt
        RAIDPARTS1[$i]="raid.0${i}"
        RAIDPARTS2[$x]="raid.0${x}"
        let x++
    done

    echo "# RAIDPARTS1=${RAIDPARTS1[@]}" >> /tmp/partitioning.txt
    echo "# RAIDPARTS2=${RAIDPARTS2[@]}" >> /tmp/partitioning.txt

    echo "raid /boot --fstype=\"xfs\" --level=1 --device=md0 ${RAIDPARTS1[@]::2}" >> /tmp/partitioning.txt
    echo "raid pv.00 --device=md1 --level=${LEVEL} ${RAIDPARTS2[@]:0}" >> /tmp/partitioning.txt

# If ONE DISK, do not use RAID
else
	{% raw %}
    x=${#DEVS2[@]}
	i=0
	{% endraw %}
    echo "zerombr" >> /tmp/partitioning.txt
    echo "clearpart --all" >> /tmp/partitioning.txt
	echo "bootloader --location=mbr --driveorder=${DEVSCSS} --append=\"crashkernel=auto rhgb quiet net.ifnames=0 biosdevname=0\"" >> /tmp/partitioning.txt
	echo "part biosboot --fstype=biosboot --size=1 --ondrive=${DEVS2[$i]}" >> /tmp/partitioning.txt
	echo "part /boot --fstype=\"xfs\" --asprimary --size=512 --ondrive=${DEVS2[$i]}" >> /tmp/partitioning.txt
    echo "part pv.00 --asprimary --size={{ provisioning_total_volgroup_size }} --ondrive=${DEVS2[$i]}" >> /tmp/partitioning.txt
fi

# Define the volume group and logical volumes
cat >> /tmp/partitioning.txt <<EOF
volgroup {{ provisioning_vgname }} --pesize={{ provisioning_storage_volgroup_pe_size }} pv.00
{% if provisioning_configure_swap | bool == true %}
logvol swap --name=LogVol00 --vgname={{ provisioning_vgname }} --size={{ provisioning_swap_size }}
{% endif %}
logvol / --fstype="xfs" --name=LogVol01 --vgname={{ provisioning_vgname }} --size={{ provisioning_volgroup00_size }}
EOF

%end

%include /tmp/partitioning.txt

reboot

#Core only packages
%packages
@core --nodefaults
python3
%end

#Post tasks
%post --interpreter=/usr/bin/bash --log=/root/ks-post.log

# Create the .ssh directory for root
mkdir /root/.ssh
chmod 700 /root/.ssh

#Add Ansible key to authorized keys
touch /root/.ssh/authorized_keys
cat > /root/.ssh/authorized_keys << EOF_authorized_keys
{{ ansible_key }}
EOF_authorized_keys
chmod 600 /root/.ssh/authorized_keys

{% if firewall_firewalld | lower == 'enabled' %}
#Could use firewall-offline-cmd
#Allow ssh for ansible only
cat > /etc/firewalld/zones/public.xml << EOF_iptables_rules
<?xml version="1.0" encoding="utf-8"?>
<zone>
  <short>Public</short>
  <description>For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.</description>
{% if ansible_server_ips is defined %}
{% for ip in ansible_server_ips %}
  <rule family="ipv4">
    <source address="{{ ip }}"/>
    <port protocol="tcp" port="22"/>
    <accept/>
  </rule>
{% endfor %}
{% endif %}
  <icmp-block name="redirect"/>
  <icmp-block name="router-advertisement"/>
  <icmp-block name="router-solicitation"/>
  <icmp-block name="source-quench"/>
</zone>
EOF_iptables_rules
{% endif %}

#Disable selinux (editing /etc/sysconfig/selinux destroys symlink, ---follow-symlinks should be used)
sed -i 's/^SELINUX=.*/SELINUX=disabled/g' /etc/selinux/config

# Persist eth100 dummy interface after install
if HWADDR=$(cat /sys/class/net/eth100/address); then
HWADDR=$(cat /sys/class/net/eth100/address)
cat > /etc/udev/rules.d/60-net.rules <<EOM_60rules
SUBSYSTEM=="net",ACTION=="add",DRIVERS=="?*",ATTR{address}=="$HWADDR",NAME="eth100"
EOM_60rules
fi

# Manually create team config files because kickstart commands have problems on initial network configuration with Ansible role
{% if network_team_interfaces is defined %}
{% for item in network_team_interfaces %}
rm -rf /etc/sysconfig/network-scripts/ifcfg-{{ item.device }}
cat > /etc/sysconfig/network-scripts/ifcfg-{{ item.device }} << EOF_team_{{ item.device }}
DEVICE="{{ item.device }}"
DEVICETYPE="Team"
ONBOOT="{{ item.onboot|default('yes') }}"
{% if item.bootproto | default('none') | lower == 'dhcp' %}
BOOTPROTO="dhcp"
{% else %}
BOOTPROTO="none"
{% if item.address is defined %}
IPADDR={{ item.address }}
NETMASK={{ item.netmask }}
{% endif %}
{% if item.gateway is defined %}
GATEWAY={{ item.gateway }}
{% endif %}
{% endif %}
{% if item.vlan is defined %}
VLAN={{ item.vlan }}
{% else %}
{% if item.runner | default('loadbalance') | lower == 'lacp' %}
TEAM_CONFIG='{"runner": {"name": "lacp","active": true,"fast_rate": true,"tx_balancer": {"name": "basic"},"tx_hash": {{ item.tx_hash | default('["eth", "ipv4", "ipv6"]') }} },"link_watch": {"name": "ethtool"}}'
{% else %}
TEAM_CONFIG='{"runner": {"name": "loadbalance","tx_hash": {{ item.tx_hash | default('["eth", "ipv4", "ipv6"]') }} }}'
{% endif %}
{% endif %}
{% if item.address is defined and item.address | ipaddr('private') and firewall_firewalld | lower == 'enabled' %}
ZONE="trusted"
{% endif %}
EOF_team_{{ item.device }}
{% if item.team_slaves is defined %}
{% for slave in item.team_slaves %}
# Use one port only, the other one is on PXE VLAN
{% if loop.first %}
rm -rf /etc/sysconfig/network-scripts/ifcfg-{{ slave.device }}
cat > /etc/sysconfig/network-scripts/ifcfg-{{ slave.device }} << EOF_slave_{{ slave.device }}
DEVICE="{{ slave.device }}"
DEVICETYPE="TeamPort"
ONBOOT="yes"
BOOTPROTO="none"
TEAM_MASTER="{{ item.device }}"
EOF_slave_{{ slave.device }}
{% endif %}
{% endfor %}
{% endif %}
{% endfor %}
{% endif %}

%end
